---
layout: post
title: Lessons from Programming Pearls
tags:
    - programming-pearls
    - problem-solving-techniques
---

## Lessons
- Problem solving techniques
- Performance
- Software engineering
- Common techniques

## Steps to solve a programming problem
1. Understand the problem
    - This also includes understanding the context where the problem arises.
    - This step is very important.
      > Defining the problem is about 90% of this battle.
2. Specify the problem in a clean and concise way
    - This step strengthens our understanding about the problem
    - It also helps to solve the problem itself, as the problem statement usually conveys an idea about the solution.
3. Explore the design space
    - Investigate possible solutions. Don't rush into the first one.
    - Keep perspective on the designs. 
4. Implement one solution
    - When it is the proper time to implement one solution, choose the solution optimal for the given situation.
    - Make tradeoffs if you have to when choosing the best solution.
5. Retrospect
    - Look back the solutions and learn. This can help us to improve the solutions and also our understanding about the solutions.
    > There remains always something to do; with sufficient study and penetration, we could improve any solution, and, in any case, we can always improve our understanding of the solution.

## Programming principles


## Column 1: Problem definition
- Careful analysis of a small problem can sometimes yield tremendous practical benefits.
- Defining the problem was about 90% of this battle
- Simple design

## Column 2: Algorithm design
- Think seriously before, during, and after coding
- Sit back and wait for an insight rather than rushing forward with the first idea
- The real skill is knowing the proper time.

## Column 3: Data structure selection
- A proper view of data does indeed structure programs
- Don't write a big program when a little will do
- Data can structure programs by replacing complicated code by a data structure
- Representation is the essence of programming
- Before writing code, good programmers thoroughly understand the input, the output, and the intermediate data structures around which their programs are built.
- Be familiar with advanced data structures

## Column 4: Writing correct programs
- One of the techniques of program verification: stating the invariant precisely and keeping an eye towards maintaining the invariant as we write each line of code
- Program verification gives programmers a language in which they can express their understanding of the problems
- Decide which assertions to include is an art that comes only with practice
- Understand the code at all times, and resist the foul urges to "just change it until it works"
- Keeping the code simple is usually the key to correctness
- Beware of not only the hard but also the easy parts

## Column 5: Perspective on performance
- Design levels
    + Problem definition
    + System structure
    + Algorithms and data structures
    + Code tuning
    + System software
    + Hardware
- Simple design
- Consider all possible levels and choose the one that delivers the most speedup for the least effort

## Column 6: The back of the envelope
- Keep it simple
- Remember to include the safety factors to compensate for our mistakes in estimating parameters and our ignorance of the problem

## Column 7: Algorithm design techniques
- Sophisticated algorithmic methods sometimes lead to dramatic performance improvements

## Column 8: Code tuning
- Locate the expensive parts of an existing program and then make changes to the code to improve its performance
- Premature optimization is the root of much programming evil
- If it ain't broke, don't fix it

## Column 9: Squeezing space
- Reducing space often has desirable side-effects on run time
- Simplicity
- Know the cost of space before you set out to reduce it

## Column 10: Sorting

## Column 11: Searching
- Asking how we might have solved it differently
- Understand the perceived problem
- Specify an abstract problem
- Explore the design space
- Implement one solution
- Retrospect

## Column 12: Heaps
- Distinguish between what a component does (the abstraction seen by user) and how it does it (the implementation inside the black box)

## Column 13: A spelling checker
- Prototypes
- Separation of concerns
- Simplicity
- Software engineering tools

## Epilog
- Book principles
    + Work on the right problem
    + Explore the design space of solutions
    + Look at the data
    + Use the back of the envelope
    + Design with components
    + Build prototypes
    + Make tradeoffs when you have to
    + Keep it simple
- Program into a language, not in it 